这是一个符合你之前开发日记风格（专业、结构化、包含技术复盘）的 Markdown 文件。你可以直接复制保存为 `DEV_DIARY_20260210_v0.9.md`。

---

# 🛠️ Mini-MES 开发日记 (2026-02-10)

> **记录者**: Run-Haji
> **状态**: v0.9 Edge Vision (PoC Failure & Re-architecture)
> **关键词**: Computer Vision, OCR, Super-Resolution, Edge Computing, Technical Debt

## 🛑 核心复盘：视觉识别方案的“滑铁卢” (The Pivot)

### 1. 任务背景 (Context)

本日的核心任务是完成边缘端（Edge Node）视觉模块 `vision.py` 的核心逻辑开发。

* **目标**: 对接 Mentor 提供的样张 `test_batch.jpg`，识别纸箱侧面的 Code-128 条形码及关键生产信息（如“草莓味”、“2025/08”）。
* **预期**: 实现毫秒级的识别响应，并通过 Mock 接口上报至后端。

### 2. 第一次受挫：传统 CV 算法的边界 (Traditional CV vs. Reality)

我们首先尝试了基于规则的传统机器视觉方案：

* **基础库**: 集成了 `zxingcpp` (C++底层) 与 `pyzbar`。
* **图像增强**: 针对低对比度样张，实现了 **CLAHE** (自适应直方图均衡化) 与 **Laplacian 锐化** 算子。
* **暴力穷举**: 编写了 `Brute Force` 模式，在一瞬间尝试 12 种不同的形态学处理组合（膨胀、腐蚀、Gamma 变换）。

**结果**: 全线失败 (`All 12 strategies failed`)。
**根本原因分析**:

1. **数据源污染**: 复盘发现 `test_batch.jpg` 并非产线工业相机实拍的 Raw Data，而是一张经过有损压缩的**渲染效果图 (Mockup)**。其条码纹理的高频信息已在压缩中丢失，导致像素发生不可逆的粘连。
2. **降维打击**: 竞品（如微信扫一扫）之所以能识别，是依赖于云端/本地的 **Deep Learning Super-Resolution (超分辨率重建)** 模型对残缺纹理进行了生成式修复。而在边缘端工控机上强行运行此类模型并不现实。

---

## 🏗️ 架构调整：OCR 方案的尝试与废弃 (The OCR Attempt)

在需求确认为“识别汉字与日期字符串”后，我们将技术栈转向 OCR (Optical Character Recognition)。

### 1. 引入 PaddleOCR (Dependency Hell)

尝试集成百度飞桨 (PaddleOCR) 轻量级模型 `PP-OCRv4`，但遭遇了严重的工程化阻碍：

* **版本碎片化**: `paddleocr` 库的新旧版本 API 变动剧烈（如 `show_log`, `use_angle_cls` 参数的废弃与改名），导致 `benchmark_ocr.py` 脚本频繁崩溃。
* **网络与模型分发**: 由于自动下载服务的不稳定，系统错误地回退到了缓存中的 **Server (服务器版)** 模型。
* *性能灾难*: 在 CPU 环境下，单张图像推理耗时高达 **44.6s**，且导致设备过热。即便优化后，推测移动端模型耗时仍在 300ms+，难以满足高速流水线的节拍要求。



### 2. 决策：奥卡姆剃刀 (Occam's Razor)

经过与 Mentor 的沟通及技术审计，我们做出了以下决策：

* **Drop OCR**: 鉴于产线生产内容的单一性（如长期生产“草莓味”），引入重型的 OCR 深度学习框架属于 **Over-engineering (过度设计)**。它引入了不必要的依赖体积（GB级）和不确定的推理延迟。
* **Cleanup**: 执行了严格的“门户清理”，移除了所有 Paddle 相关依赖及模型文件，回滚了 `requirements.txt`。

---

## 🔭 下一步规划：回归极简主义 (Back to Basics)

### v0.9 Revised Strategy (修正策略)

既然我们的目标是“验证”，而非“阅读”，我们将采用更底层、更高效的方案。

* **Template Matching (模板匹配)**:
* 使用 OpenCV 的 `cv2.matchTemplate`。
* **原理**: 将“草莓味”等关键词制作成标准模板（Template），在视频流中进行滑动窗口匹配。
* **优势**: 确定性高，无需训练，无需 GPU，耗时预计 **< 20ms**。



### 资产归档 (Archiving)

为了保持项目整洁，同时保留未来的可能性：

* 保留 `src/edge_node/services/vision.py` 的图像预处理框架（灰度、切图逻辑）。
* 保留 `client/mock_device.py` 用于后续网络通讯测试。
* 将 `make_barcode.py` 与 `clean_test.png` 归档至 `utils/` 与 `backup/` 目录，作为回归测试的基准数据 (Benchmark)。

---

## 📝 总结 (Summary)

今天最大的收获不是代码，而是对 **"Input Quality" (输入质量)** 和 **"Technology Fit" (技术适配度)** 的深刻理解。
在边缘计算场景下，**并不是模型越先进越好，而是越稳定、越轻量越好。** 明天我们将用最朴素的代码解决最实际的问题。